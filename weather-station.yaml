#-------------------------------------------
# BUG AND REPAIR
#-------------------------------------------
# fix uv state
# apply nwe formula dew point Tdp =(243.04 × [ln(RH/100) + ( (17.625×T) / (243.04+T) )]) / (17.625 - [ln(RH/100) + ( (17.625×T) / (243.04+T) )])

#-------------------------------------------
# SUBTITUTIONS - basic definitions and description of the device
#-------------------------------------------
substitutions:
  device_name: ESP-Weatherstation
  friendly_name: Weather-station
  created_by: StudioTiiM 2021-2023
  device_description: "A complete battery-powered weather monitoring station"

#-------------------------------------------
# POWER CONSUMPTION 
# whit multimeter
#-------------------------------------------
# Power consumption 12V
# First booting MCU + MCU CAM: 300mA
# Booting MCU: 180mA
# Heating sensors: 130mA
# Normal: 40mA
# Deep sleep: 17mA

# Power consumption 5V
# First booting MCU + MCU CAM: 510mA
# Booting MCU after connected to mqtt: 350mA
# Heating sensors: 330mA
# Normal: 270mA
# Deep sleep: 

#-------------------------------------------
# DEFINE PINS AND VARIABILES
# CIRCUIT AND MODULES - basic definitions and description of the device
#-------------------------------------------

 # ----- LEDS -----
  # Modul: Status led
   # Specification: 1x red led
   # Circuit: 10Ω resistor to GPIO
   # Power consumption: 15mA
  status_led: GPIO02
  # Modul: Spotlight
   # Specification: 8x high brightness white leds
   # Circuit: 15Ω resistor to 5V / switching whit NPN Darlington TIP122: Gate - 220Ω GPIO / Gate-Source 10kΩ pulldown
   # Power consumption: 200mA (1pic = 3.3V 25mA)
  spotlight: GPIO26

 # ----- SMOKE SENSOR -----
  # Module: MQ-2 Smoke and Gas Sensor
   # Specification: Voltage	5V / Load resistance 20kΩ / Heater resistance	33Ω ± 5% / Heating consumption	<800mw / Sensing Resistance	10 KΩ ~ 60 KΩ / Concentration Range	200 ~ 10000ppm / Preheat Time	Over 24 hour
   # Power consumption: preheat 135mA / standby 
   # Settings: time heating and measure min. 100s
   # RL replace resistor 1kΩ to 2kΩ
   # https://circuitdigest.com/microcontroller-projects/arduino-smoke-detector-on-pcb-using-mq2-gas-sensor
   # First stable value after 90s
  mq2_pin: GPIO39 # SVP
  # Calibrate:
  # Look datasheet and MQ-2 Gas Sensor Sensitivity Characteristics in Graph:
   # https://thestempedia.com/tutorials/interfacing-mq-2-gas-sensor-with-evive/
   # The graph tells us the concentration of a gas in part per million (ppm) according to the resistance ratio of the sensor (RS/R0).
    # RS is the resistance of the sensor that changes depending on the concentration of gas.
    # R0 is the resistance of the sensor at a known concentration without the presence of other gases, or in the fresh air.

    # RS = (Vin - Vout) / Vout
    
   # After 15 min. ready "MQ2 - R0" value and repace ro value
  r0_value: "1.565"
   
   # Calculating PPM for a particular gas
   # Analyze the graph:

    # - The scale of the graph is log-log. This means that in a linear scale, the behavior of the gas concentration with respect to the resistance ratio is exponential.
    # - The data for gas concentration only ranges from 200 ppm to 10000 ppm.
    # - Even though the relation between resistance ratio and gas concentration may seem linear, in reality, it is not.

   # First of all, we will treat the lines as if they were linear. This way we can use one formula that linearly relates the ratio and the concentration. 
   # By doing so, we can find the concentration of a gas at any ratio value even outside of the graph’s boundaries.
   # The formula we will be using is the equation for a line, but for a log-log scale. The formula for a line is:
   
   # Math:
    # y: X value              y = mx + b   
    # x: X value              x = 10 ^ {[log(y) - b] / m}
    # m: Slope of the line    m = log(y/y0) / log(x/x0)
    # b: Y intercept          b = log(y) - m*log(x)

    # For a log-log scale, the formula looks like this:  
    #  log(y) = m*log(x) + b  

    # Measure Smoke and CO calculate a defines in the sensor field

 # ----- TEMPERATURE / HUMIDITY / PRESSURE SENSORS -----
  # Module: Dallas DS18B20
   # Circuit: 4.7k resistor data pin to VCC
   # Power consumption: 50uA
   # Measure: Solar panel and Battery
  dallas_pin: GPIO23
   # UPDATE AFTER BOOT: 1s

  # Module: BME280 - pressure / humidity / temperature (ALT. DHT21 AM2301 750uA; BMP280)
   # Specifications: Voltage: 1.8 ~ 5V / Operational Range: Temperature: -40 ~ +85°C Humidity: 0~100% Pressure: 300~1100 hPa / Accuracy: Temperature: +-1°C Humidity: +-3% Pressure: +-1Pa
   # Circuit: Interface: I2C address: SDO LOW : 0x76 (SDO HIGH: 0x77)
   # Power consumption: 0.4mA
   # UPDATE AFTER BOOT: 1s /if solar panel > 30°C 15s
  
 # ----- FAN RADIATION SHIELD -----
  # Module: 5V Fan 600rpm 50mm (low consumption)
   # Specification: Voltage	5V / Consmption max. 150mA / 600RPM
   # Power consumption: high speed: 150mA / normal speed 100mA / low speed 70mA
   # Circuit: FAN PWM control / switching whit NPN Darlington TIP122: Gate - 220Ω GPIO / Gate-Source 10kΩ pulldown
  fan_pwm_pin: GPIO19

 # ----- RAIN SENSORS -----
  # Module: MS-WH-SP-RG rain gauge
   # Specifications: volume 0.2794 l
   # Circuit: VCC-sensor(reed switch)sensor-GPIO-10kΩ pulldown-GND
   # Features additional: wake up pin
  rain_gauge: GPIO25

   # UPDATE AFTER BOOT: 50kΩ = 10s / < 50kΩ = 30s

  # Module: MH-RD Raindrops
   # Circuit: GND and ADC pin
   # Consumption: standby 0uA / dry 1.4uA / full wet 10mA
  rain_drop: GPIO34
   # increasing the lifetime of raindrops module
   # Circuit: GPIO-ADCraindrops 10k resistor - GPIO turn on measure ADC pin
  raindrop_switch: GPIO5
   # Variabiles
  resistor_value: "9.9kOhm"   # rain drop resistor
  measure_interval_dry: "10s" # In dry mode
  measure_interval_wet: "30s" # In wet mode / Must be large enough not to damage the tracks prematurely, but small enough to be reactive enough.

 # ----- CO2 SENSOR -----
  # Module: MHZ19 Intelligent Infrared CO2 Module
   # Specifications: Voltage 3.6 ~ 5.5V / Average current < 18 mA /  / Preheat time 3 min / Reponse Time T90 < 60s / Working temperature 0 ~ 50 °C Working humidity 0 ~ 95% RH (No condensation) / Lifespan > 5 years
   # Circuit: Interface UART level 3.3 V
   # Power consumption: preheat 85mA / standby 9mA / pwm heating 90mA (cycle 5-6s 24°C)
   # UPDATE AFTER BOOT: 50s

 # ----- PARTICULATE MATTER SENSOR -----
  # Module: IKEA VINDRIKTNING Particulate Matter Sensor with PM1006 pm 2.5 (whitout original mcu board)
   # Specifications: Voltage working 5V +-0.2 / Range 0 ~ 1000μg/m³ / Working temperature -20 ~ 75 °C Working humidity 0 ~ 95% RH (No condensation)
   # Circuit: Interface UART level 4.5 V baude rate 9600 connected level-shifter reverse TX RX.
   # Consumption: standby 7.6mA
  # Module: original IKEA VINDRIKTNING Fan 5V
   # Circuit: add protect diode
   # Consumption: 30mA
   # UPDATE AFTER BOOT: 90s + 5x measure filter 5s = 95s
   
 # ----- REDUCER CONSUMPTION -----
  # "Settings: time heating and measure min 3min delay measure (10x per day)"
   # delay measure and minimal consumption battery: MQ2 smoke sensor and IKEA VINDRIKTNING Particulate Matter Sensor
   # Circuit: switching whit NPN power mofset IRFZ44N: Gate - 100Ω GPIO / Gate-Source 1kΩ pulldown
  reducer_consumption_pin: GPIO27

 # ----- SUN SENSORS -----
  # Module: BH1750 GY-302 lux meter
   # Specifications: 3V ~ 5V / Range:  1 ~ 65 535 lx
   # Circuit: Interface: I2C address: 0x23
   # Consumption: normal 4.4mA
   # http://wiki.sunfounder.cc/index.php?title=GY-302_BH1750_Digital_Light_Intensity_Module

  # Module: GYML8511 UV uv light uva uvb ultraviolet 
   # Specifications: 3V – 5V / Photodiode sensitive to UV-A and UV-B
   # Circuit: ADC
   # Consumption: normal 0.455mA
   # http://wiki.sunfounder.cc/index.php?title=GYML8511_UV_Sensor
  uv_pin: GPIO35

 # ----- WIND SENSORS -----
  # Module: WH-SP-WS01 wind speed anemometer
   # Circuit: 10k resitor GPIO to VCC and GPIO 104 capacitor to GND
  wind_speed_pin: GPIO32
   # Variabiles for calculating wind speed:    
  pulse_revolution: "2" # Number of pulses by revolution 
  radius: "0.09"        # Blade circle radius in meters
  math_pi: "3.1416"     # π
  factor: "1.18"        # Calibration factor compensate friction (you can adjust it)

  # Module: WH-SP-WD wind direction
   # Resistors table: 
   # ANGLE(°)   RESISTOR (kΩ)
   # ---------------------------
   #   0.0      33.00
   #  22.5       6.57
   #  45.0 	    8.20
   #  67.5 	    0.891
   #  90.0 	    1.00
   # 112.5 	    0.688
   # 135.0	    2.20
   # 157.5 	    1.41
   # 180.0 	    3.90
   # 202.5 	    3.14
   # 225.0 	   16.00
   # 247.5 	   14.12
   # 270.0 	  120.00
   # 292.5 	   42.12
   # 315.0 	   64.90
   # 337.5 	   21.88
   # ---------------------------
   # Circuit: 10k resitor GPIO to VCC and GPIO 104 capacitor to GND
  wind_direction_pin: GPIO33

 # ----- RADIATION SENSORS -----
  # Module: Geiger-Counter-RadiationD-v1.1-CAJOE
   # Specifications: Voltage 4.5 ~ 6V / measure range 20mR/h~120mR/h γ X-ray and 100 ～ 1800 degeneracy/min · cm2 soft β For radiation
   # Geiger Muller tube: mounted J321 (360 - 440 V, dimension 10x86mm, lifespan  1 × 109 pulses)
   # Circuit:  on esp32 only VP-GPIO36 or VN-GPIO39 high impedance pin (connected P3 header 5V/GND/VIN(pulse pin))
   # Consumption: 6.66mA (reducer unmount 2x NE555 timer IC1 and U80 header =  speaker and led)
   # https://esphome.io/cookbook/geiger-counter.html
   # https://www.youtube.com/watch?v=K28Az3-gV7E
  geiger_pin: GPIO36 # connected to module to VIN pin
  
  # Calculate correct value:
  # Alert value >0.81uSv/h >100cpm
   # calculate tube m4011, mounted J321 
   # Gamma Sensitivity Ra226 (cps/mR/hr) 27 (SBM-20 tube = 29)
   # Gamma Sensitivity Co60 (cps/mR/hr) 22
   # (27+22)/2=24.5
   # Multiply counts per second by 60 to get CPM: 24.5 x 60 = 1470 CPM
   # absorption rate to be use is 8.77 which I understand is for air
   # So finally the 1530 CPM is divided by the absorption rate of 8.77 to get ratio between CPM and uSv: 1470 / 8.77 = 167.617
   # inverse 0.00596598639455782312925170068027
   # https://sites.google.com/site/diygeigercounter/technical/gm-tubes-supported (method 2)

 # ----- CHARGING -----
  # Module: Solar panel 18V
   # Specification: 18V 25W   (50W alliexpress :D)
   # Type: Monocrystalline 
   # Solar panel dimension
  width_panel: "0.315" # m
  height_panel: "0.480" # m
  
  # Module: Charger Step Down XL4015 E1 
   # Specification: Voltage in: 4V ~ 37V out: 1.25V ~ 36V 5A efficiency: ~96% (current standby 20mA) 
   # Setup: OUT 12.9V/1A (connected protect diode SS34: Voltage Forwarde 0.5V = 12.4V to battery pack)
   
 # ----- BATTERY -----
  # --- old version battery ---
  # Battery: 12V 9Ah 20h max input 13.7V/1.0A (sealed rechargeable acid battery EMOS model OT 9-12)
  # Theoretical battery life: current consumption 300mA / Life: 8 Days

  # --- new version battery ----
  # Battery: 9x 18650 3.7V/2500mAh 
   # Circuit: 3x parallel 3x series 12.4V/7.5Ah out.
   # Protection 1: BMS 3S 20A hw-375 rev2.3
    # Specification: overcharge 4.25V / discharge 2.5V /overcurrent 22A / Working temperature -40- 85 °C
    # Consumption: standby: 20uA
   # Protection 2: Polarized power relay latching relay (Signal two coil) ADW1203HL 3V3 16A protect two diode SS110 and 2xNPN BC337 10kΩ pulldown and 100Ω to GPIO
    # Specification: battery < 9.4V (3.13V one battery) switch to power supply / if current solar > current mcu switch to battery
  power_supply_off_pin: GPIO04
  power_supply_on_pin: GPIO18
  capacite_battery: "7.5"    # 7.5Ah
  efficiency_charging: "1.3" # efficiency of memory and battery characteristics (20-60%)
   
 # ----- MEASUREMENT OF ELECTRICITY 
  # Module: INA3221 3CH DC current sensor black board
   # Specification: Voltage in 26V / Voltage operating 2.7 - 5.5V / Working temperature -40 ~ 125 °C / shunt resistor 0.1Ω max current I=V/R; I = 0.1638 mV / 0.1Ω = 1.638 A max
   # Circuit: Interface: I2C address: 0x40
   # Consumption: standby 350uA
  
 # ----- LDO REGULATORS -----
  # Module: step down DD2712SA 5V (alt. OKI-78SR-5/1.5)
   # Specification: Voltage in 6.5 ~ 27V out fixed 5V / current max 2.5A; short 3.5A / frequency: 900kHz / efficiency 75 ~ 92% / stadby current: 250uA / protection: overtemperature; undervoltage; short-circuit; Working temperature -20 ~ 85 °C
  # Module: holtek HT7833 (2x = ESP32cam and ESP32 main mcu)
   # Specification: Voltage in 0-8 out fixed 3.3V 2% / max voltage drop 360mV / current max 0.5A / current standby 0.22mA (datasheet standby current 4uA) / protection: overtemperature; current limiting

#-------------------------------------------
# VARIABILES
#-------------------------------------------
# Update intreval for all sensors
  update_time: 60s 

#-------------------------------------------
# PROTOCOLS
#-------------------------------------------
 # ----- PROTOCOLS PINS -----
  # i2c
  i2c_sda_pin: GPIO21
  i2c_scl_pin: GPIO22
  # uart
  uart_rx_pin: GPIO17
  uart_tx_pin: GPIO16
  uart2_rx_pin: GPIO14
  uart2_tx_pin: GPIO13

 # ----- PROTOCOLS SETTINGS -----
uart:
  - id: uart2 # ikea vindriktining pm1006
    rx_pin: "$uart2_rx_pin"
    tx_pin: "$uart2_tx_pin"
    baud_rate: 9600
  
  - id: uart1 # mhz-19 co2
    rx_pin: "$uart_rx_pin"
    tx_pin: "$uart_tx_pin"
    baud_rate: 9600

i2c:
  sda: "$i2c_sda_pin"
  scl: "$i2c_scl_pin"
  scan: false

dallas:
  - pin: "$dallas_pin"
    update_interval: $update_time

#-------------------------------------------
# ESP - MAIN SETTINGS
#-------------------------------------------
esphome:
  name: weather-station
  project:
    name: "studiotiim.weather_station"
    version: 3.1.0
  platformio_options:
    board_build.f_cpu: 160000000L # set cpu clock 160mhz
  on_boot:
    - priority: 900
      then:
        # Find how to esp wake up (deep sleep cycle or rtc pin wake up)
        # Rain-gauge add one measuring when is wake up whit gauge pin
        lambda: |-
          id(wake_up_pin) = ((log(esp_sleep_get_ext1_wakeup_status()))/log(2));;
          esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON); //INTERNAL PD

    - priority: 600
      then:
        #- lambda: id(deep_sleep_prevent_rainfall).publish_state(true);
        - lambda: id(deep_sleep_prevent).publish_state(false); # on boot send template state fals

    - priority: -200 # when everithing should by inicialized
      then:
        - switch.turn_on: resistance_bias # turn on resistance on raindrop sensor
        # - if: 
            # condition:
            #   mqtt.connected: # send online state when mqtt is connected to wifi and server
            #then:
        - text_sensor.template.publish:  # Send online state when wifi is connected 
            id: online_status
            state: "Online"
    - priority: -400  # delay so that the device is not overloaded at startup
      then:
        - delay: 5s
        - switch.turn_on: switch_reducer_consumption # turn on measure pm1006 and mq2 sensor less load when booting
        - text_sensor.template.publish: # second send online 
            id: online_status
            state: "Online"

  on_shutdown: # send offline state when mcu power off or go to deep sleep
    priority: -801.0 # tested more settings the server does not always receive the value
    then:
      - text_sensor.template.publish:
          id: online_status
          state: "Offline"

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:

#-------------------------------------------
# MQTT
#-------------------------------------------
mqtt:
  broker: '192.168.31.212'
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true

  # online first message
  birth_message:
    topic: $device_name/status_on
    payload: online
  # drop connected message
  will_message:
    topic: $device_name/status_unaiavalable
    payload: unavailable
  # offline last message
  shutdown_message:
    topic: $device_name/status_off
    payload: offline
  # OTA message
  on_message:
    - topic: $device_name/ota_mode
      payload: 'ON'
      then:
        - deep_sleep.prevent: deep_sleep_component
        - logger.log: "OTA blocking deep sleep"

    - topic: $device_name/ota_mode
      payload: 'OFF'
      then:
        - logger.log: "Ota finished back to deep sleep allow"
        - deep_sleep.allow: deep_sleep_component

ota:
  password: !secret ota_pass

wifi:
  manual_ip:
    static_ip: 192.168.31.59
    gateway: 192.168.31.1
    subnet: 255.255.255.0
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "$device_name Hotspot"
    password: "passweatherstation"

captive_portal:

#-------------------------------------------
# DEEP SLEEP COMPONENT
#-------------------------------------------
deep_sleep:
  run_duration: 150s # all sensor send state (in time 100s)
  sleep_duration: 13min
  #sleep_duration: 2min # testing time
  id: deep_sleep_component
  esp32_ext1_wakeup: 
    pins: 
      - $rain_gauge
    mode: ANY_HIGH 
  #wakeup_pin_mode: KEEP_AWAKE # when is high no deepsleep enter

#-------------------------------------------
# SCRIPTS
#-------------------------------------------
script:
#-------------------------------------------
# Deep sleep script allow
# prevent deep sleep when raindrop detected
# if raindrop sensor is wet, it's probably raining, a rain gauge can record the amount of water
# after raindrop sensor dry go to deep sleep after 100s
#-------------------------------------------
  - id: deep_sleep_script 
    mode: single
    then:
      - logger.log: 
          format: "ALLOW DEEPSLEEP + 95s"
          level: warn
      - delay: 95s
      - text_sensor.template.publish:
          id: online_status
          state: "Offline"
      - logger.log: 
          format: "BEGIN DEEPSLEEP + 5s"
          level: warn
      - delay: 5s
      - deep_sleep.allow: deep_sleep_component

#-------------------------------------------
# GLOBALS
#-------------------------------------------
globals:
#-------------------------------------------
# RESTORE VALUE BME280 module
#-------------------------------------------
  - id: temp_global
    type: float
    restore_value: yes
    initial_value: '20.0'

  - id: humidity_global
    type: float
    restore_value: yes
    initial_value: '50.0'

  - id: pressure_global
    type: float
    restore_value: yes
    initial_value: '1000'

#-------------------------------------------
# RESTORE VALUE power state (battery/power supply switch)
#-------------------------------------------
  - id: power_state_global
    type: bool
    restore_value: yes
    initial_value: "false"

#-------------------------------------------
# RESTORE VALUE esp_sleep_get_ext1_wakeup_status
# Rain-gauge add one measuring when is wake up whit gauge pin
#-------------------------------------------
  - id: wake_up_pin
    type: uint64_t
    restore_value: no
    initial_value: '0'

#-------------------------------------------
# STATUS LED
# red led on cam spotlíght
#-------------------------------------------
status_led:
  pin:
    number: ${status_led}

#-------------------------------------------
# TEXT SENSORS
#-------------------------------------------
text_sensor:
#-------------------------------------------
# Online state mcu
# bug no send online or offline does always state 
#-------------------------------------------
  - platform: template
    id: online_status
    name: "${friendly_name} Status"
    lambda: |-
      return {"Loading"};
    icon: "mdi:power-standby"
    update_interval: never
    entity_category: diagnostic

#-------------------------------------------
# Rain drop text sensor 
# ... on boot loading
#-------------------------------------------
  - platform: template
    id: rain_status
    name: "${friendly_name} Rainfall Sensor"
    lambda: |-
      return {"Loading"};
    icon: "mdi:waterfall"
    update_interval: never

#-------------------------------------------
# Wind direction text sensor
# ... on boot loading
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Wind Direction"
    id: wind_dir_card
    lambda: |-
      return {"Loading"};
    update_interval: never
    icon: mdi:weather-windy

#-------------------------------------------
# Battery Condition
# ... on boot loading
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Battery Condition"
    id: text_battery_condition
    lambda: |-
      return {"Loading"};
    update_interval: never
    icon: mdi:battery-heart-outline
    entity_category: diagnostic

#-------------------------------------------
# SENSORS
#-------------------------------------------
sensor:
#-------------------------------------------
# Internal board esp temperature
#-------------------------------------------
  - platform: template
    id: temp
    name: "${friendly_name} Temperature MCU"
    lambda: return temperatureRead();
    filters:
      - filter_out: 53.3 # bug 53.3 send state only 
    unit_of_measurement: "°C"
    update_interval: "$update_time"
    icon: mdi:thermometer
    entity_category: diagnostic

#-------------------------------------------
# Wifi signal component
#-------------------------------------------
  - platform: wifi_signal
    name: "${friendly_name} Signal"
    update_interval: "$update_time"

#-------------------------------------------
# LUX sensor - BH1750
#-------------------------------------------
  - platform: bh1750
    name: "${friendly_name} LUX"
    address: 0x23
    accuracy_decimals: 0
    update_interval: "$update_time"

#-------------------------------------------
# Smoke detector - MQ-2 Smoke and Gas Sensor
#-------------------------------------------
  - platform: adc
    name: "${friendly_name} MQ2 - RAW"
    pin: "$mq2_pin"
    update_interval: "1s"
    attenuation: 11db
    accuracy_decimals: 3
    id: mq2_raw
    icon: "mdi:smoke"
    filters:
      - median:
          window_size: 4
          send_every: 4
          send_first_at: 4
    entity_category: config
    on_value:
      then:
        - component.update: mq2_ro
        - component.update: mq2_smoke
        - component.update: mq2_co

#-------------------------------------------
# MQ2 - RO 
# read when first started and preheated for 24 hours, read the value after 15 minutes
#-------------------------------------------
  - platform: template
    name: "${friendly_name} MQ2 - R0"
    id: mq2_ro
    accuracy_decimals: 4
    update_interval: never
    icon: "mdi:smoke"
    unit_of_measurement: "R0"
    entity_category: config
    lambda: |-
      const float air_rs_ro = 9.8;                                                // From the graph, we can see that the resistance ratio in fresh air is a constant: RS / R0 = 9.8
      const float vdc = id(voltage_out).state;                                    // 5.0V or input sensor vdc to esp32
      // RO= ((5.0 - adc                ) / adc                ) / 9.8            // formula in excel
      return ((vdc - id(mq2_raw).state) / id(mq2_raw).state) / air_rs_ro;     // 

    # In the table given below, you can find the value of m and b for different gases.
    # --------------------------------------------------------------
    # Gas       Value   Value     Value         m             b
    #           at 200  at 10000  at 5000  
    # --------------------------------------------------------------
    # H2        2.1     0.33      0.460    -0.473054470  1.412572126
    # LPG       1.6     0.27      0.370    -0.454838059  1.250634060
    # Methane   3.0     0.70      0.940    -0.372003751  1.349158571
    # CO        5.1     1.35      1.800    -0.339756680  1.512022272
    # Alcohol   2.8     0.65      0.850    -0.373311285  1.310286169
    # Smoke     3.4     0.60      0.950    -0.443402570  1.617856412
    # Propane   1.7     0.28      0.385    -0.461038681  1.290828982
    # --------------------------------------------------------------

#-------------------------------------------
# MQ2 - Smoke
#-------------------------------------------
  - platform: template
    name: "${friendly_name} MQ2 - Smoke"
    id: mq2_smoke
    unit_of_measurement: ppm
    accuracy_decimals: 0
    update_interval: never
    device_class: carbon_dioxide
    icon: "mdi:smoke"
    lambda: |-      
      const float x_left = 200.0;    // straight line for smoke x min value
      const float y_up = 3.4;        // straight line for smoke y max value
      const float x_right = 10000.0; // straight line for smoke x max value
      const float y_down = 0.6;      // straight line for smoke y min value
      
      const float x_middle = 5000.0; // straight line for smoke middle point
      const float y_middle = 0.95;   // straight line for smoke middle point
      
      const float vdc = id(voltage_out).state - 0.1;         // 5.0V or input sensor vdc to esp32
       
      //=   POWER(10; (LOG10 (((5.0 - ADC                ) / ADC                ) / 0,4)- (LOG10 (0,95)     - (LOG10 (0,6    / 3,4 ) / LOG10 (10000   / 200   )) * LOG10 (5000    ))) / (LOG10 (0,6    / 3,4 ) / LOG10 (10000   / 200   )))      formula in excel
      return powf(10, (log10f(((vdc - id(mq2_raw).state) / id(mq2_raw).state) / ${r0_value}) - (log10f(y_middle) - (log10f(y_down / y_up) / log10f(x_right / x_left)) * log10f(x_middle))) / (log10f(y_down / y_up) / log10f(x_right / x_left)));
    filters:
      - lambda: 'return min((float)10000.0, x);'
      
#-------------------------------------------
# MQ2 - CO
#-------------------------------------------
  - platform: template
    name: "${friendly_name} MQ2 - CO"
    id: mq2_co
    unit_of_measurement: ppm
    accuracy_decimals: 0
    update_interval: never
    device_class: carbon_dioxide
    icon: "mdi:smoke"
    lambda: |-
      const float x_left = 200.0;    // straight line for smoke x min value
      const float y_up = 5.1;        // straight line for smoke y max value
      const float x_right = 10000.0; // straight line for smoke x max value
      const float y_down = 1.35;     // straight line for smoke y min value
      
      const float x_middle = 5000.0; // straight line for smoke middle point
      const float y_middle = 1.8;    // straight line for smoke middle point
      
      const float vdc = id(voltage_out).state - 0.1;         // 5.0V or input sensor vdc to esp32
      
      return powf(10, (log10f(((vdc - id(mq2_raw).state) / id(mq2_raw).state) / ${r0_value}) - (log10f(y_middle) - (log10f(y_down / y_up) / log10f(x_right / x_left)) * log10f(x_middle))) / (log10f(y_down / y_up) / log10f(x_right / x_left)));
    filters:
      - lambda: 'return min((float)10000.0, x);'
#-------------------------------------------
# DALLAS temperature sensor - DS18B20 
# connected 4.7k to VCC 
#-------------------------------------------
# Temperature solar panel
  - platform: dallas
    address: 0x3bf4f1871e64ff28
    
    name: "${friendly_name} Temperature Solar Panel"
    id: temp_solar
    entity_category: diagnostic
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    on_value:
    # update bme280 sensor condition fan
      - if: 
          condition: 
            sensor.in_range:
              id: temp_solar
              above: 30.0
          then: 
            - fan.turn_on:
                id: radiationshield_fan
                speed: 95 # + 100mA 15s
            - delay: 15s
            - fan.turn_off:
                id: radiationshield_fan
            - component.update: temperature_temp
            - component.update: pressure_temp
            - component.update: humidity_temp
          else:
            - component.update: temperature_temp
            - component.update: pressure_temp
            - component.update: humidity_temp
            
# Temperature battery
  - platform: dallas
    address: 0x7111dafb0264ff28
    name: "${friendly_name} Temperature Battery"
    id: temp_battery
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    entity_category: diagnostic
        
#-------------------------------------------
# Temperature humidity pressure sensor - BME280
#-------------------------------------------
  - platform: bme280
    temperature:
      id: temperature_sensor
     # oversampling: 8x
      on_value:
        then:
          - component.update: dew_point
          - globals.set:
              id: temp_global
              value: !lambda 'return x;'
      internal: True
    pressure:
      id: pressure_sensor
      internal: True
      on_value:
        then:
          - globals.set:
              id: pressure_global
              value: !lambda 'return x;'
    humidity:
      name: "${friendly_name} Humidity"
      id: humidity_sensor
      internal: True
      on_value:
        then:
          - globals.set:
              id: humidity_global
              value: !lambda 'return x;'
    address: 0x76
    update_interval: 14s

#-------------------------------------------
# Template - Temperature humidity pressure
# component update manually control whit fan and temperature solar panel
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Temperature"
    id: temperature_temp
    update_interval: never
    unit_of_measurement: "°C"
    icon: "mdi:thermometer"
    lambda: "return id(temp_global);"
  - platform: template
    name: "${friendly_name} Pressure"
    id: pressure_temp
    update_interval: never
    unit_of_measurement: "hPa"
    icon: "mdi:gauge"
    lambda: "return id(pressure_global);"
    accuracy_decimals: 0
  - platform: template
    name: "${friendly_name} Humidity"
    id: humidity_temp
    update_interval: never
    unit_of_measurement: "%"
    icon: "mdi:thermometer"
    lambda: "return id(humidity_global);"

#-------------------------------------------
# Template - Dew point
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Temperature Dew Point"
    id: dew_point
    icon: "mdi:thermometer"
    unit_of_measurement: "°C"
    update_interval: never
    lambda: |-
      return (id(temperature_sensor).state - (100 - id(humidity_sensor).state) / 5);  

#-------------------------------------------
# Wind Speed - WH-SP-WS01
#
# Specification for calculating speed
# Number of pulses by revolution            pulse_revolution = 1 pulses (sensor has 2 magnet 2 pulses. but 1Hz give good values)
# Blade radius to center                    radius           = 0.09 m
# Circumference in meter                    circ_m           = radius * 2 * π = 0.09 * 2 * 3.14 = 0.5652 m
# Rotation per second                       rotation         = pulse / pulse_revolution / 60 = 1 / 1 / 60 = 0.01667
# Calibration factor compensate friction    factor           = 1.18 (you can adjust it)
# Meter per second                          mps              = factor * circ_m * rotation = 1.18 * 0.5652 * 0.01667 = 0.01111 m/s
# kilometer per hour                        kmh              = mps * 3.6 = 0.04 km/h
# 
# datasheet 2.4km/h per second 
#-------------------------------------------
  - platform: pulse_counter
    pin: 
      number: "$wind_speed_pin"
      mode:
        input: true
        pullup: true
    unit_of_measurement: 'km/h'
    name: "${friendly_name} Wind Speed"
    icon: 'mdi:weather-windy'
    count_mode:
      rising_edge: DISABLE
      falling_edge: INCREMENT
    internal_filter: 13us
    filters:
      - lambda: return x * ((${factor} * (${radius} * 2 * ${math_pi}) * 1 / ${pulse_revolution} / 60) * 3.6 ); 
      # multiply: 0.04

#-------------------------------------------
# Wind direction - WH-SP-WD
#-------------------------------------------
  - platform: adc
    id: source_sensor
    pin: "$wind_direction_pin"
    attenuation: 11db
    internal: true
    accuracy_decimals: 1
    filters:
      - multiply: 0.846153 # 3.9 -> 3.3V
      - median:
          window_size: 5
          send_every: 5
          send_first_at: 1
    update_interval: $update_time

  - platform: resistance
    sensor: source_sensor
    id: resistance_sensor_wind
    configuration: DOWNSTREAM
    resistor: 10kOhm
    internal: true
#    name: ${friendly_name} - Resistance Sensor
    reference_voltage: 3.9V
    accuracy_decimals: 1
    on_value:
    #SEVER
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 4000
              below: 5500
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "J"
            - sensor.template.publish:
                id: wind_heading
                state: 180
    #SEVEROVÝCHOD
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 500
              below: 800
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "JZ"
            - sensor.template.publish:
                id: wind_heading
                state: 225
    #VÝCHOD
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 1400
              below: 2200
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "Z"
            - sensor.template.publish:
                id: wind_heading
                state: 270
    #JUHOVÝCHOD
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 2000
              below: 3000
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "SZ"
            - sensor.template.publish:
                id: wind_heading
                state: 315
    #JUH
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 7500
              below: 10000
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "S"
            - sensor.template.publish:
                id: wind_heading
                state: 0
    #JUHOZÁPAD
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 19500
              below: 21500
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "SV"
            - sensor.template.publish:
                id: wind_heading
                state: 45
    #ZÁPAD
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 15000
              below: 17500
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "V"
            - sensor.template.publish:
                id: wind_heading
                state: 90
    #SEVEROZÁPAD
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_wind
              above: 11000
              below: 13000
          then:
            - text_sensor.template.publish:
                id: wind_dir_card
                state: "JV"
            - sensor.template.publish:
                id: wind_heading
                state: 135

  - platform: template
    name: "${friendly_name} Wind Heading"
    id: wind_heading
    unit_of_measurement: "°"
    icon: mdi:weather-windy
    accuracy_decimals: 0

#-------------------------------------------
# UV index - GUVA-S12SD
#-------------------------------------------
  - platform: adc
    id: adcuv
    pin: "$uv_pin"
    attenuation: 11dB
    name: "${friendly_name} UV Intensity"
    update_interval: "$update_time"
    filters:
      #- lambda: 'return max((float)0.99, x);' # original in datasheet minimum 0.99
      - lambda: 'return max((float)1.03, x);'  # measure more time min. 0.99-1.03
      - lambda: 'return min((float)2.8, x);'
    unit_of_measurement: 'mW/cm²'
    on_value:
      then:
        component.update: uv_index
    icon: 'mdi:sunglasses'
#    device_class: irradiance # bug

  - platform: template
    name: "${friendly_name} UV Index"
    id: uv_index
    lambda: |-
       return ((id(adcuv).state - 1.03) * (15.0 - 0.0) / (2.8 - 1.0) + 0.0);
       // return ((id(adcuv).state - 0.99) * (15.0 - 0.0) / (2.8 - 0.99) + 0.0);
    update_interval: "never"
    unit_of_measurement: "UV"
    icon: 'mdi:sunglasses'
    filters:
      - calibrate_polynomial:
         degree: 3
         datapoints:
          # calibrate whit hydrometeorology institute still measure and calibrate sensor not final 
          - 0.0 -> 0.0
          - 0.1 -> 0.0
          - 1.4 -> 5.0
          - 3.5 -> 8.0
          - 10.0 -> 14.5
          - 15.0 -> 15.0
      - lambda: 'return max((float)0, x);'
 
#-------------------------------------------
# CO2 sensor - MHZ19
#-------------------------------------------
  - platform: mhz19
    co2:
      name: "${friendly_name} CO2"
    temperature:
      name: "${friendly_name} Temperature CO2"
      accuracy_decimals: 1
    update_interval: "$update_time"
    # abc mhz calibration switch turn on/off automatic baseline calibration 
    # automatic_baseline_calibration: True
    uart_id: uart1
    id: mhz19_co2

#-------------------------------------------
# Electricity component - INA3221 3CH DC current sensor
#-------------------------------------------
  - platform: ina3221
    address: 0x40
    # solar panel
    channel_1:
      shunt_resistance: 0.1 ohm
      current:
        name: "${friendly_name} Current Solar"
        accuracy_decimals: 0
        id: current_solar
        entity_category: diagnostic
        filters:
          - multiply: 1000 # convert A to mA 
          - median:
              window_size: 3
              send_every: 3
              send_first_at: 3
        unit_of_measurement: mA
      power:
        name: "${friendly_name} Power Solar"
        accuracy_decimals: 2
        id: solar_power
        entity_category: diagnostic
      bus_voltage:
        name: "${friendly_name} Voltage Solar"
        entity_category: diagnostic
      shunt_voltage:
        name: "${friendly_name} Shunt Voltage Solar"
        internal: true
    # battery charge
    channel_2:
      shunt_resistance: 0.1 ohm
      current:
        name: "${friendly_name} Current Battery"
        id: current_battery
        entity_category: diagnostic
        filters:
          - multiply: 1000 # convert A to mA 
          - median:
              window_size: 3
              send_every: 3
              send_first_at: 3
        unit_of_measurement: mA
        accuracy_decimals: 0
        on_value:
          then:
            - component.update: current_value
      power:
        name: "${friendly_name} Power Battery"
        entity_category: diagnostic
      bus_voltage:
        name: "${friendly_name} Voltage Battery"
        id: battery_voltage
        entity_category: diagnostic
        filters:
          - quantile:
              window_size: 5
              send_every: 5
              send_first_at: 5
              quantile: .5
        #battery condition script
        on_value:
          then:
            - component.update: battery
            - if:
                condition:
                  sensor.in_range:
                    id: temp_battery
                    above: 35.0
                then:
                  - text_sensor.template.publish:
                      id: text_battery_condition
                      state: "WARNING OVERHEAT!"
                else:
                  - if:
                      condition:
                        lambda: "return (id(current_solar).state) > (id(current_mcu).state);"
                      then:
                        - switch.turn_on: power_supply_off
                        - if: 
                            condition:
                              - sensor.in_range:
                                  id: battery_voltage
                                  below: 10.0
                            then:
                              - text_sensor.template.publish:
                                  id: text_battery_condition
                                  state: "Charging / LOW"
                            else:
                              - text_sensor.template.publish:
                                  id: text_battery_condition
                                  state: "Charging"
                      else:
                        if:
                          condition:
                            - binary_sensor.is_on: power_state
                          then:
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 4.0
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Supply / No battery"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 8.4
                                      above: 4.0
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Supply / Critical Low"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 10.5
                                      above: 8.4
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Supply / Low"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 12.4
                                      above: 10.5
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Supply / Normal"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      above: 12.4
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Supply / Full"
                          else:
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 8.4
                                then:
                                  - switch.turn_on: power_supply_on
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Critical Low"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 9.5
                                      above: 8.4
                                then:
                                  - switch.turn_on: power_supply_on
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Low"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 10.0
                                      above: 9.5
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Low"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      below: 12.4
                                      above: 10.0
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Normal"
                            - if:
                                condition:
                                  - sensor.in_range:
                                      id: battery_voltage
                                      above: 12.4
                                then:
                                  - text_sensor.template.publish:
                                      id: text_battery_condition
                                      state: "Full"

      shunt_voltage:
        name: "${friendly_name} Shunt Voltage Battery"
        internal: true
    #out
    channel_3:
      shunt_resistance: 0.1 ohm
      current:
        name: "${friendly_name} Current Out"
        accuracy_decimals: 0
        id: current_out
        entity_category: diagnostic
        on_value:
          then:
            component.update: current_mcu
        filters:
          - multiply: 1000
          - median:
              window_size: 3
              send_every: 3
              send_first_at: 3
        unit_of_measurement: mA
      power:
        name: "${friendly_name} Power Out"
        accuracy_decimals: 2
        entity_category: diagnostic
      bus_voltage:
        name: "${friendly_name} Voltage Out"
        entity_category: diagnostic
        id: voltage_out
      shunt_voltage:
        name: "${friendly_name} Shunt Voltage Out"
        internal: true
    update_interval: "2s"

#-------------------------------------------
# Template sensor - Current Out state
# Bug whitout this sensor: ERROR Circular dependency detected!
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Current Mcu"
    id: current_mcu
    lambda: "return id(current_out).state;"
    update_interval: never
    entity_category: diagnostic
    internal: True

#-------------------------------------------
# Total energy
#-------------------------------------------
  - platform: total_daily_energy
    name: "${friendly_name} Solar Energy"
    power_id: solar_power
    icon: "mdi:solar-power"
    on_value:
      then:
        - component.update: solar_radia
    accuracy_decimals: 2

#-------------------------------------------
# Solar radiation component
#
# watt*(1m2/(a*b))*24
# 1 kW/m2 × (24 h/day) = (24 kWh/m2)/day
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Solar Radiation"
    icon: "mdi:solar-power"
    unit_of_measurement: "(W/m²)/day"
    id: solar_radia
    lambda: |-
      return (id(solar_power).state * (1 / ($width_panel * $height_panel)) * 24);
    update_interval: never
    accuracy_decimals: 0

#-------------------------------------------
# Battery - template sensor units %
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Battery"
    lambda: |-
      return (id(battery_voltage).state);
    filters:
      - calibrate_linear:
          - 12.54 -> 100
          - 9.5 -> 0
      - lambda: 'return min((float)100.0, x);'
      - lambda: 'return max((float)0.0, x);'
    accuracy_decimals: 0
    update_interval: never
    entity_category: diagnostic
    unit_of_measurement: "%"
    device_class: battery
    id: battery

#-------------------------------------------
# Battery - charging time hours
# Time charging= ((Capacity battery[Ah] - (Capacity battery[Ah] / 100[%] * Battery capacite[%])) * Efficiency characteristics) / Current charging[A]
#-------------------------------------------
  # Prevent + charging value
  - platform: template
    name: "${friendly_name} Charging Value"
    internal: True
    lambda: |-
      return (id(current_battery).state);
    filters:
    #  - lambda: 'return max((float)0.0, x);'
      - multiply: 0.001
      - quantile:
          window_size: 5
          send_every: 5
          send_first_at: 5
          quantile: .5

    accuracy_decimals: 3
    update_interval: never
    entity_category: diagnostic
    unit_of_measurement: "A"
    device_class: battery
    id: current_value
    on_value:
      if:
        condition:
          sensor.in_range:
            id: current_battery
            below: 0.0
        # CHARGING
        then:
          - sensor.template.publish:
              id: battery_charging_time
              state: !lambda "return ((${capacite_battery} - (${capacite_battery} / 100 * id(battery).state)) * ${efficiency_charging}) / id(current_value).state;"
        # DISCHARGING
        else:
          - sensor.template.publish:
              id: battery_charging_time
              state: !lambda "return ((${capacite_battery} / 100 * id(battery).state)) / (id(current_value).state * 1.2);"

  - platform: template
    name: "${friendly_name} Battery Dis/Charging Time"
    lambda: "return 0.0;"
    accuracy_decimals: 1
    update_interval: never
    entity_category: diagnostic
    unit_of_measurement: "h"
    device_class: battery
    id: battery_charging_time
    icon: mdi:battery-clock
    filters:
      # filter range for a clear graph statistic
      - lambda: 'return min((float)120.0, x);'
      - lambda: 'return max((float)-120.0, x);'

#-------------------------------------------
# IKEA VINDRIKTNING Particulate Matter Sensor with PM1006 inside
# pm 2.5
#-------------------------------------------
  - platform: pm1006
    id: particulate_matter
    pm_2_5:
      name: "${friendly_name} PM2.5"
      filters:
      - median:
          window_size: 4
          send_every: 4
          send_first_at: 4
    update_interval: "never"
    uart_id: uart2

#-------------------------------------------
# Rain drops sensor MH-RD Raindrops
# Dry     > 49000 Ω
# Wet     < 49000 Ω
# Raining < 4000  Ω
#-------------------------------------------
  # ADC
  - platform: adc
    id: rain_drop_adc
    pin: "$rain_drop"
    name: "${friendly_name} Rainfall Drop Raw"
    attenuation: 11db
    internal: true
    # It is important to have a low update interval so that
    # the measurement has time to be done correctly during
    # the activation of the voltage AND taking into account the median filter
    update_interval: never
    filters:
      - median:
          window_size: 5
          send_every: 5
          send_first_at: 5

  # RESISTANCE
  - platform: resistance
    sensor: rain_drop_adc
    id: resistance_sensor_rain
    name: "${friendly_name} Rainfall Drop"
    configuration: DOWNSTREAM
    resistor: $resistor_value
    reference_voltage: 3.3V
    icon: "mdi:waterfall"
    unit_of_measurement: 'kΩ'
    filters:
      # No value lower than 1 000ohm
      - lambda: 'return max((float)1000, x);'
      # No value greater than 80 000ohm
      - lambda: 'return min((float)80000, x);'
      - multiply: 0.001 # convert ohm to kiloohm
    accuracy_decimals: 1
    on_value:
      - if:
          condition:
            sensor.in_range:
              id: resistance_sensor_rain
              above: 49.000
          then:
            - text_sensor.template.publish:
                id: rain_status
                state: "Dry"
            - delay: 5s
            - if:
                condition:
                  and:
                    - binary_sensor.is_off: deep_sleep_prevent
                    - binary_sensor.is_off: deep_sleep_prevent_rainfall
                then:
                  - script.execute: deep_sleep_script
                else:
                  - if:
                      condition:
                        or:
                          - binary_sensor.is_on: deep_sleep_prevent
                          - binary_sensor.is_on: deep_sleep_prevent_rainfall
                      then:
                        - script.stop: deep_sleep_script
                        - deep_sleep.prevent: deep_sleep_component
                        - logger.log: 
                            format: "RAINGAUGE OR PRESS PREVENT DEEPSLEEP"
                            level: warn
          else:
            - if:
                condition:
                  sensor.in_range:
                    id: resistance_sensor_rain
                    above: 4.000
                    below: 49.000
                then:
                  - text_sensor.template.publish:
                      id: rain_status
                      state: "Wet"
                else:
                  - text_sensor.template.publish:
                      id: rain_status
                      state: "Raining"
            - if:
                condition:
                  or:
                    - sensor.in_range:
                        id: resistance_sensor_rain
                        below: 49.000
                    - binary_sensor.is_on: deep_sleep_prevent_rainfall
                    - binary_sensor.is_on: deep_sleep_prevent
                then:
                  - script.stop: deep_sleep_script
                  - deep_sleep.prevent: deep_sleep_component
                  - logger.log: 
                      format: "WET MEASURE PREVENT DEEPSLEEP"
                      level: warn

#-------------------------------------------
# Rain gauge sensor - MS-WH-SP-RG
#-------------------------------------------
  - platform: pulse_counter
    pin:
      number: "$rain_gauge"
      mode: INPUT_PULLDOWN
    unit_of_measurement: 'mm/min'
    name: "${friendly_name} Rainfall raw"
    #icon: 'mdi:weather-rainy'
    id: rain_gauge_raw
    count_mode:
      rising_edge: DISABLE
      falling_edge: INCREMENT
    internal_filter: 13us
    update_interval: 60s
    filters:
    # volume one pulse 0.2794 l
      - multiply: 0.2794
    accuracy_decimals: 2
    on_value:
      then:
        - sensor.template.publish:
            id: rain_gauge
            state: !lambda "return id(rain_gauge_raw).state;"

  - platform: template
    name: "${friendly_name} Wake Up Pin"
    id: wake_up_pin_temp
    accuracy_decimals: 0
    internal: True
    lambda: |-
      return (id(wake_up_pin));
    on_value:
      if:
        condition:
          sensor.in_range:
            id: wake_up_pin_temp
            below: 30
        then:
          - sensor.template.publish:
              id: rain_gauge
              state: 0.2794
        
  - platform: template
    name: "${friendly_name} Rainfall"
    id: rain_gauge
    icon: 'mdi:weather-rainy'
    filters:
      lambda: if (isnan(x)) {  return 0.0; } return x;
    unit_of_measurement: 'mm/min'
    accuracy_decimals: 2
    #expire_after: 60s
    
    
# Can not be when deep sleep enable
#  - platform: total_daily_energy
#    name: "${friendly_name} Rainfall Daily"
#    power_id: rain_gauge
#    unit_of_measurement: 'mm'
#    icon: 'mdi:weather-rainy'
#    # x60 To convert to aggregated rain amount
#    filters:
#      - multiply: 60
#    accuracy_decimals: 2
#    device_class: distance

#-------------------------------------------
# Pulse counter - Geiger module 

# Correct value:
# >0.81 >100cpm alert
# calculate tube m4011, mounted J321 
# Gamma Sensitivity Ra226 (cps/mR/hr) 27 (SBM-20 tube = 29)
# Gamma Sensitivity Co60 (cps/mR/hr) 22
# (27+22)/2=24.5
# Multiply counts per second by 60 to get CPM: 24.5 x 60 = 1470 CPM
# absorption rate to be use is 8.77 which I understand is for air
# So finally the 1530 CPM is divided by the absorption rate of 8.77 to get ratio between CPM and uSv: 1470 / 8.77 = 167.617
# inverse 0.00596598639455782312925170068027
# https://sites.google.com/site/diygeigercounter/technical/gm-tubes-supported (method 2)
#-------------------------------------------

  # CPM
  - platform: pulse_counter
    pin: "$geiger_pin"
    id: geigercounter
    internal: true
    #name: "${friendly_name} Radiation Count"
    #unit_of_measurement: 'CPM'
    #accuracy_decimals: 0
    count_mode:
      rising_edge: DISABLE
      falling_edge: INCREMENT
    icon: mdi:radioactive
    update_interval: 1s
    # internal_filter: 190us
    filters:
      - lambda: return x * 1 / 60; 
    # total one minute cpm
    total:
      unit_of_measurement: 'CPM'
      id: geigercounter_total_cpm
      internal: True
            
  # CPM - template 
  # only send measure time
  - platform: template
    name: "${friendly_name} Radiation Count"
    id: radiation_cpm
    icon: mdi:radioactive
    unit_of_measurement: 'CPM'
    accuracy_decimals: 0
    update_interval: never
    lambda: "return (id (geigercounter_total_cpm).state);"
    filters:
      filter_out: nan
    on_value:
      then:
        - sensor.template.publish:
            id: radiation_power
            state: !lambda "return (id(radiation_cpm).state * 0.005966);"

  # µSv/h
  - platform: template
    name: "${friendly_name} Radiation Power"
    id: radiation_power
    icon: mdi:radioactive
    unit_of_measurement: 'µSv/h'
    accuracy_decimals: 3
    filters:
      filter_out: nan

#-------------------------------------------
# BINARY SENSORS
#-------------------------------------------
binary_sensor:
#-------------------------------------------
# Power supply template
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Power Supply"
    id: power_state
    icon: mdi:power-plug
    entity_category: diagnostic
    lambda: "return id(power_state_global);"

#-------------------------------------------
# Deep Sleep binary template 
#-------------------------------------------
  - platform: template
    name: "${friendly_name} Deep Sleep - Prevent"
    id: deep_sleep_prevent
    icon: mdi:power-sleep
    entity_category: config

# Deep Sleep prevent if rain gauge measure rainfall 
  - platform: gpio
    pin:
      number: "$rain_gauge"
    filters:
      - delayed_off: 60s
    name: "${friendly_name} Deep Sleep - Prevent Rainfall"
    id: deep_sleep_prevent_rainfall
    icon: mdi:power-sleep
    publish_initial_state: true
    entity_category: config

#-------------------------------------------
# SWITCHES
#-------------------------------------------
switch:
#-------------------------------------------
# Power Relay switch
# Polarized power relay latching relay
#-------------------------------------------
  - platform: gpio
    pin: $power_supply_on_pin #25
    name: "${friendly_name} Power Supply ON"
    on_turn_on:
      - delay: 150ms
      - switch.turn_off: power_supply_on
      - globals.set:
          id: power_state_global
          value: "true"
    id: power_supply_on
    entity_category: config
    icon: mdi:power-plug
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: $power_supply_off_pin #04
    name: "${friendly_name} Power Supply OFF"
    on_turn_on:
      - delay: 150ms
      - switch.turn_off: power_supply_off
      - globals.set:
          id: power_state_global
          value: "false"
    id: power_supply_off
    entity_category: config
    icon: mdi:power-plug-off
    restore_mode: ALWAYS_OFF

#-------------------------------------------
# Switch - Rain drop - low destruction sensor
#-------------------------------------------
  - platform: gpio
    id: resistance_bias
    name: "${friendly_name} Rainfall Drop - Measure "
    icon: "mdi:waterfall"
    entity_category: config
    pin:
      number: "$raindrop_switch"
      mode: OUTPUT
      drive_strength: 10mA
    on_turn_on:
      then:
        - component.update: rain_drop_adc
        - delay: 500ms
        - component.update: rain_drop_adc
        - delay: 500ms
        - component.update: rain_drop_adc
        - delay: 500ms
        - component.update: rain_drop_adc
        - delay: 500ms
        - component.update: rain_drop_adc
        - delay: 500ms
        - component.update: rain_drop_adc
        - delay: 500ms
        - switch.turn_off: resistance_bias

#-------------------------------------------
# CO2 sensor - MHZ19 - Auto Calibrate Baseline
#-------------------------------------------
  - platform: template
    name: "${friendly_name} MH-Z19 - Calibrate ABC"
    icon: mdi:molecule-co2
    optimistic: true
    on_turn_on:
      mhz19.abc_enable: mhz19_co2
    on_turn_off:
      mhz19.abc_disable: mhz19_co2
    entity_category: config

#-------------------------------------------
# Repeat measure reducer power consumption 5V modules
# Smoke, PM2.5 + internal fan
# Wiring whit IRFZ44N power mofset
#-------------------------------------------
  - platform: gpio
    name: "${friendly_name} PM1006 MQ2 - Measure"
    icon: mdi:air-filter
    restore_mode: ALWAYS_OFF
    pin:
      number: "$reducer_consumption_pin"
    id: switch_reducer_consumption
    on_turn_on:
      - then:
          - delay: 5s
          - pulse_counter.set_total_pulses:
              id: geigercounter
              value: "0"
          - delay: 60s # wait time to heat mq2 and fan replaces the air
          # update component 5 time (window size 5)
          - component.update: mq2_raw
          - component.update: particulate_matter
          - component.update: radiation_cpm
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - component.update: geigercounter
          - pulse_counter.set_total_pulses:
              id: geigercounter
              value: "0"
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - delay: 500ms
          #- switch.turn_off: switch_reducer_consumption
          - logger.log: 
              format: "MEASURE pm1006/mq2/radiation COMPLETE"
              level: warn
    entity_category: config

#-------------------------------------------
# Manual update component
#-------------------------------------------
  - platform: template
    name: "${friendly_name} PM1006, MQ2 - Update"
    icon: mdi:air-filter
    turn_on_action:
      - then:
          - component.update: mq2_raw
          - component.update: particulate_matter
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - component.update: geigercounter
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - delay: 1s
          - component.update: mq2_raw
          - component.update: particulate_matter
          - logger.log: 
              format: "MANUAL MEASURE pm1006/mq2/radiation COMPLETE"
              level: warn
    entity_category: config

#-------------------------------------------
# BUTTONS
#-------------------------------------------
button:
#-------------------------------------------
# Deep Sleep button
#-------------------------------------------
  - platform: template
    name: "${friendly_name} DeepSleep - Disable"
    icon: mdi:power-sleep
    id: deepsleep_switch
    entity_category: config
    on_press:
      then:
        - binary_sensor.template.publish:
            id: deep_sleep_prevent
            state: True
        - script.stop: deep_sleep_script
        - logger.log: 
            format: "SWITCH PREVENT DEEPSLEEP"
            level: warn
        - deep_sleep.prevent: deep_sleep_component

#--------------------------------------------
# MHZ Calibrate zero point
# Calibrate after 20min in static indoor air 
#--------------------------------------------
  - platform: template
    name: "${friendly_name} MHZ-19 Calibrate Zero"
    on_press:
      then:
        - mhz19.calibrate_zero: mhz19_co2
    entity_category: config

#-------------------------------------------
# RESTART
#-------------------------------------------
  - platform: restart
    name: "${friendly_name} Restart"

#-------------------------------------------
# INTERVALS - Reducer measurement cycling
#-------------------------------------------
interval:
  # reducer conumption switch repeat measure
  - interval: 15min
    then:
      - switch.turn_on: switch_reducer_consumption

  # rain drop sensor repeat measure
  - interval: $measure_interval_wet
    then:
      if:
        condition:
          sensor.in_range:
            id: resistance_sensor_rain
            below: 49.000
        then:
          - switch.turn_on: resistance_bias
          - logger.log: 
              format: "WET MEASURE TIME"
              level: warn
  - interval: $measure_interval_dry
    then:
      if:
        condition:
          sensor.in_range:
            id: resistance_sensor_rain
            above: 49.000
        then:
          - switch.turn_on: resistance_bias
          - logger.log: 
              format: "DRY MEASURE TIME"
              level: warn

#-------------------------------------------
# TIME COMPONENT
#-------------------------------------------
time:
  - platform: sntp
    id: esptime
    timezone: "Europe/Bratislava"

#-------------------------------------------
# OUTPUTS
#-------------------------------------------
output:
#-------------------------------------------
# RadiationShield Fan 5V
# control whit PWM NPN Darlington TIP122
#-------------------------------------------
  - platform: ledc
    pin: "$fan_pwm_pin"
    frequency: 20000 Hz
    id: radiationshield_fan_pwm
    #min_power: 0.0 # min power 70mA power consumption
    max_power: 0.80 # max power 150mA power consumption

  - id: spotlight_output
    platform: gpio
    pin: "$spotlight"

fan:
  - platform: speed
    output: radiationshield_fan_pwm
    name: "${friendly_name} RadiationShield Fan"
    id: radiationshield_fan

#-------------------------------------------
# Spotlight - white 8x white led 3.3V
#-------------------------------------------
light:
  - platform: binary
    name: "${friendly_name} Led White"
    output: spotlight_output
    icon: mdi:spotlight-beam
